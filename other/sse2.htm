<!DOCTYPE html>
<html>
    <head>
        <style>
            body {
                font-family: Arial, Helvetica, sans-serif;
            }
            #graphs {
                height:400px;
                width: 700px;
                position:relative;
            }
            #graphs canvas {
                position:absolute;
                top: 0;
                left: 0;
                height:400px;
                width: 700px;
            }

            hr {
                opacity: 0.1;
                margin:18px;
            }

            input {
                width: 36px;
                border: 0;
                font-size: 12pt;
            }

            input[type=number] {
                appearance:textfield; /* Firefox */
            }


            .caption {
                /*padding:4px 20px;*/
                text-align: right;
            }



            #sse-hypothesis, #sse-lcdm {
                text-align: right;
                font-weight: bold;
            }

            .MathJax {
                font-size: 5pt !important;
            }

            #legend {
                position: absolute;
                left: 350px;
                top:335px;
            }
            #y-axis {
                position: absolute;
                top: -15px;
                left: 25px;
            }
        </style>
    </head>
<body>

<h3>Supernovae Data - Sum of Squared Errors</h3>

<p>
    Read more about the hypothesis being tested <a href="../index.htm">on the home page.</a> 
</p>


<div id="graph-side">
    <div id="graphs">
    <canvas id="background" height="400" width="700"></canvas>
    <canvas id="graph" height="400" width="700"></canvas>
    <table id="y-axis">
        <tr>
            <td>\[\chi^2 = \Sigma_i (\mu_i^{d} - \mu_i^{m})^2 / \sigma^2 \]</td>
        </tr>
    </table>
    </div>

    <p>Data: <a href="https://github.com/PantheonPlusSH0ES/DataRelease/tree/main/Pantheon%2B_Data/4_DISTANCES_AND_COVAR">
        Pantheon+SH0ES, Distances and Covariances
    </a></p>

    <table>
        <tr>
            <td>Squared Sum of Errors:</td>
            <td>\[\chi^2= \Sigma_i (d_i^{d} - d_i^{m})^2 \]</td>
            <td>where <i>d<sub>d</sub></i> is the distance modulus in the data, and <i>d<sub>m</sub></i> is the distance predicted by the model.</td>
        
        </tr>
    </table>
    <table id="legend">
        <tr>
            <td class="caption">Hypothesis (<span style="color:red;">red</span>): </td>
            <td>\[  d_L = (1+z)\frac{c}{H_{0}} log(1 + z)  \]</td>
        </tr>
        <tr>
            <td class="caption">&Lambda;CDM (<span style="color:green;">green</span>): </td>
            <td>&Omega;<sub>M</sub> + &Omega;<sub>&Lambda;</sub> = 1</td>
        </tr>
    </table>
    
    <br>
    <br>
    <button id="recalculate">Recalculate LCDM</button> (Press this after changing LCDM parameters... and wait 10 seconds...)
    <br>
    <br>
    <input id="useerrorbars" type="checkbox">Use Error Bars</input> 
    <br>
    <br>
    <input id="usemu" type="checkbox" checked="true">Use Mu</input> 
</div>

<script src="lcdm.js"></script>

<script>

const Hstart = 60
const Hend = 80.5

var sse = []
var sseHypothesis = 0
var sseLCDM = 0

document.getElementById("recalculate").onclick = e => {
    calculateLCDMErrors()
    drawData()
}

var black = false

    var details = document.getElementById("details")

    var background = document.getElementById("background")
    var graph = document.getElementById("graph")
    var ctxB = background.getContext("2d")
    var ctxG = graph.getContext("2d")

    var useMuEl = document.getElementById("usemu")
    var useMu = useMuEl.checked
    useMuEl.onchange = e => {
        useMu = !useMu
        zoomGY = getZoom()
        calculateDistances()
        drawGraph()
        drawData()
        calculateLCDMErrors()
    }

    var useErrorEl = document.getElementById("useerrorbars")
    var useError = useErrorEl.checked
    useErrorEl.onchange = e => {
        console.log("onchange")
        useError = !useError //useErrorEl.value
        zoomGY = getZoom()
        calculateDistances()
        drawGraph()
        calculateLCDMErrors()
        drawData()
    }

    var c = 1
    const pc2ly = 3.261564
    const c0 = 299792.458
        

    var offset = 20
    var zoom = 1
    var zoomG = (graph.width - offset) / (10) //zoom 

    var getZoom = () => {
        if (useMu) {
            return useError ? zoom * 0.2 : zoom * 3 
        }
        else {
            return  (useError ? zoom / 1200000 : zoom / 70000)   
        }
    }
    var zoomGY = getZoom()
    
    var snData = []
    

    var calculateDistances = function () {
        

        var extinction = 0
        for (var i=0; i<snData.length; i++) {
                // distance modulus to parsec luminosity distance
                var ld = Math.pow(10, 0.2 * (snData[i].dm + 5 - extinction)) 

                // convert to comoving distance
                //d = ld / (1+z)
                var d = ld / (1 + snData[i].z)

                // parsec to light years
                //d = d * pc2ly
                //ld = ld * pc2ly

                // ly to Mly
                snData[i].d = d / 1000000
                snData[i].ld = ld / 1000000

        }

        sse = []

        for (var iH = Hstart; iH < Hend; iH += 0.1) {
            sseHypothesis = 0
            sseLCDM = 0

            snData.forEach(sn => {
                sseHypothesis += calculateError(sn, iH)
            })
            sse.push({H: iH, 
                hypothesis: sseHypothesis, 
                lcdm: sseLCDM    
            })
        }
        
    }
    
    
    function drawGraph() {
        sseHypothesis = 0
        
        ctxB.lineWidth = 2
        ctxB.fillStyle = black ? "black" : "white"
        ctxB.fillRect(0, 0, graph.width, graph.height)

        ctxB.strokeStyle = !black ? "black" : "white"
        ctxB.strokeRect(offset, -10, graph.width, graph.height + 10 - offset)
        
        ctxB.font = "14px sans-serif"

        ctxB.fillRect(offset + 16, offset + 33, 2, 2)
        ctxB.fillStyle = "black"
        


        ctxB.fillStyle = !black ? "black" : "white"
        ctxB.textAlign = "left"
        //ctxB.fillText("SSE to Pantheon+SH0ES", offset + 5, offset)

        ctxB.textAlign = "right"
        ctxB.fillText("Ω", graph.width - 10, graph.height - 30)
        ctxB.font = "10px sans-serif"
        ctxB.fillText("Λ", graph.width - 4, graph.height - 30 + 4)
        
        
        ctxB.textAlign = "left"
        var dgi
        ctxB.font = "10px sans-serif"
        ctxB.fillStyle = "black"
        var range = useMu ? !useError ? [0.00005, 0.0001] : [0.001, 0.002] : !useError ? [5, 25] : [100, 1000]
        for (dgi = 0; dgi <= range[1] * 1e6; dgi+=range[0] * 1e6) {
            ctxB.fillText(dgi.toString().replace("000", "K"), 0, -offset + graph.height - dgi * zoomGY + 4)    
        }
        
        for (dgi = 0; dgi < 11; dgi+=1) {
            ctxB.fillText(dgi/10, offset + dgi * zoomG - 5, graph.height - 5)    
        }        
    }

    function drawData() {
        var hypothesis = useError ? 839.3 : 55.01
        graph.width = graph.width
        ctxG.fillStyle = !black ? "black" : "white"
            
        ctxG.lineWidth = 1
        ctxG.strokeStyle = "green"
        ctxG.beginPath()
        ctxG.moveTo(offset, graph.height - sses[0].lowest.sse * zoomGY - offset) 
        sses.forEach(data => {
            ctxG.lineTo(offset + (data.omegaL * 10) * zoomG, 
                    -offset + graph.height - data.lowest.sse * zoomGY) //
        })
        ctxG.stroke()
        
        ctxG.strokeStyle = "red"
        ctxG.beginPath()
        ctxG.moveTo(offset, graph.height - hypothesis * zoomGY - offset)

        ctxG.lineTo(offset + graph.width * zoomG, 
                    -offset + graph.height - hypothesis * zoomGY)
        ctxG.stroke()
        
    }

    drawGraph()

    fetch("https://mikehelland.github.io/hubbles-law/data/lcdmsse.json").then(res => res.json()).then(data => {
        //console.log(text)

        sses = data
        calculateDistances()
        drawData()
        
    })

    fetch("https://mikehelland.github.io/hubbles-law/data/Pantheon+SH0ES_z_mu.csv").then(res => res.text()).then(text => {
        //this is here in case you want to call calculateLCDMErrors() manually

        var lines = text.split("\n")
        for (var i = 1; i < lines.length; i++) {
            var line = lines[i].split(",")
            if (line[0]) {
                var sn = {"dm": parseFloat(line[2]), "z": parseFloat(line[0]), "derr": parseFloat(line[3])}
                snData.push(sn)

            }
            
        }
        
    })


    function calculateDistanceModulus(d) {
        return 5 * Math.log10(d) + 25 
    }
    
    
    function calculateError(sn, H) {

        var d = c0 / H * Math.log(1 + sn.z)
        var dd

        if (useMu) {
            
            d = calculateDistanceModulus(d * (1 + sn.z)) 
            dd = sn.dm
        }
        else {
            dd = sn.d 
        }

        if (Math.round(H * 10) === 710) {
            //console.log(dd, d)
        }
        
        return Math.pow(dd - d, 2) / (useError ? Math.pow(sn.derr, 2) : 1)
                
    }

    function calculateLCDMError(iH, omegaL, omegaM, sn) {
        sseLCDM = 0
        
        var dlcdm = LCDM(iH, omegaL, omegaM, sn.z).DC 
        //var dlcdm = zToD(sn.z) 
        var dd 
        
        if (useMu) {
            dlcdm = dlcdm * (1 + sn.z) 
            dlcdm = calculateDistanceModulus(dlcdm)
            dd = sn.dm
        }
        else {
            dd = sn.d 
        }    
        
        return Math.pow(dd - dlcdm, 2) / (useError ? Math.pow(sn.derr, 2) : 1) 
        
    }

    var sses = []
    var handle
    var grandLowest
    function calculateLCDMErrors() {
        clearInterval(handle)
        console.log("calcaulting lcdms")
        sses = []
        var sseLCDM
        var i = 0
        grandLowest = 0
        for (var i = 0; i < 21; i++) {
            var omegaL = i / 20
            var sse = []
            console.log("omegaL=" + omegaL)
            var lowest = 0
    
            for (var iH = Hstart; iH < Hend; iH += 1) {

                sseLCDM = 0
                snData.forEach(sn => {
                    sseLCDM += calculateLCDMError(iH, omegaL, Math.max(1 - omegaL, 0), sn)
                })

                if (!lowest || lowest.sse > sseLCDM) {
                    lowest = {omegaL, H: iH, sse: sseLCDM}
                }
                if (!grandLowest || grandLowest.sse > sseLCDM) {
                    grandLowest = {omegaL, H: iH, sse: sseLCDM}
                }
                sse.push({
                    H: iH,
                    omegaL,
                    sse: sseLCDM
                })
            }
            sses.push({data: sse, lowest, omegaL})

        }
    }



    
</script>

<script type="text/javascript" src="https://www.hostmath.com/Math/MathJax.js?config=OK"></script>
