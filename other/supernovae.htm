<!DOCTYPE html>
<html>
    <head>
        <style>
            body {
                font-family: Arial, Helvetica, sans-serif;
            }
            #graphs {
                height:400px;
                width: 700px;
                position:relative;
            }
            #graphs canvas {
                position:absolute;
                top: 0;
                left: 0;
                height:400px;
                width: 700px;
            }

            hr {
                opacity: 0.1;
                margin:18px;
            }

            input {
                width: 80px;
            }


            td, th {
                padding:4px 20px;
            }

            #hypothesiseq {
                display: none;
                position: absolute;
                left: 480px;
                top: 425px;
            }


            #sse-hypothesis, #sse-lcdm {
                text-align: right;
                font-weight: bold;
            }

            #lcdm {
                position: absolute;
                left:220px;
                top:450px;
            }

        </style>
    </head>
<body>

<h3>Supernovae Data </h3>

<p>
    Read more about the hypothesis being tested <a href="../index.htm">on the home page.</a> 
</p>


<div id="graph-side">
    X-axis: 
    <select id="graph-x-axis">
        <option>z redshift</option>
        <option>co-moving distance (Gly)</option>
        <option>luminosity distance (Gly)</option>
    </select>
    <br>    
    Y-axis: 
    <select id="graph-y-axis">
        <option>distance (Gly)</option>
        <option>luminosity distance (Gly)</option>
        <option>distance modulus (Î¼)</option>
        
    </select>
    <br>
    <div id="graphs">
    <canvas id="background" height="400" width="700"></canvas>
    <canvas id="graph" height="400" width="700"></canvas>
    </div>
    <br>
    Zoom X: <input type="number" id="graph-zoom-x" value="1.0" step="0.01" min="0.01">
    Zoom Y: <input type="number" id="graph-zoom-y" value="1.0" step="0.01" min="0.01">
    <br>
    Width: <input type="number" id="graph-width" value="600" >
    Height: <input type="number" id="graph-height" value="600" >
    <div id="extinction-container">
        <br>
        Light Extinction=<input id="extinction" type="number" value="0.0" step="0.01" min="0.0">
        <br>
        Hypothesis2 R: <input value="0" type="number" id="graph-hypothesis2">
        </div>
    <br>
    Hypothesis H<sub>0</sub>: <input value="70" type="number" id="graph-hypothesis">
    <br>
    <div id="lcdm">
        &Lambda;CDM (<span style="color:green;">green</span>): 
        H<sub>0</sub>: <input type="number" value="73" step="0.5" id="H0">
        &Omega;<sub>M</sub>: <input type="number" min="0" value="0.3" step="0.05" id="Omega_M">
        &Omega;<sub>&Lambda;</sub>: <input type="number" min="0" value="0.7" step="0.05" id="Omega_L">
    </div>

    <hr>
    <div id="Errors">
        Sum of Squared Errors:
    <table>
        <tr>
            <td>Hypothesis</td>
            <td id="sse-hypothesis"></td>
        </tr>
        <tr>
            <td>LCDM</td>
            <td id="sse-lcdm"></td>
        </tr>
    </table>
    </div>
</div>

<div id="right-side">

</div>


<div id="hypothesiseq">
    <!--\[  d = \frac{c}{H_{0}} log(1 + z)  \]-->
    \[  H_{0} = 70~\text{km s}^{-1}~\text{Mpc}^{-1}  \]
</div>


<script>

var sseHypothesis = 0
var sseLCDM = 0

var sseHypothesisDiv = document.getElementById("sse-hypothesis")
var sseLCDMDiv = document.getElementById("sse-lcdm")

var drawHypothesis = document.getElementById("graph-hypothesis")


var black = false

    var details = document.getElementById("details")

    var background = document.getElementById("background")
    var graph = document.getElementById("graph")
    var ctxB = background.getContext("2d")
    var ctxG = graph.getContext("2d")
    var models = []

    var extinctionInput = document.getElementById("extinction")
    extinctionInput.onchange = e => {
        calculateDistances()
        drawSN()
    }

    var calculateDistances = function () {
        var extinction = extinctionInput.value
        for (var i=0; i<snData.length; i++) {
                // distance modulus to parsec luminosity distance
                var ld = Math.pow(10, 0.2 * (1*snData[i].dm + 5 - extinction)) 

                // convert to comoving distance
                //d = ld / (1+z)
                var d = ld / (1+snData[i].z) // (1+snData[i].z)  

                // parsec to light years
                d = d * 3.261564
                ld = ld * 3.261564

                // ly to Mly
                snData[i].d = d / 1000000
                snData[i].ld = ld / 1000000
        }
        
    }
    
    
    // the models advance by 1 million years each step
    // the units for distance are in Mly (million light years)

    // the speed of light is 1 million lightyears per million years
    
    // Hubble's Constant (H) is in units of Gly^-1 or ly/y/Gly, so it is divided by 1000  

    var c = 1
    const pc2ly = 3.261564
    const c0 = 299792.458
        

    var zoom = 0.035
    var zoom_gx = 0.8
    var zoom_gy = 0.48
    var zoomG = zoom * zoom_gx
    var zoomGY = zoom * zoom_gy
    var offset = 20
    
    var zZoom = 10000

    var drawnSN = false

    var snData = []
    var zData = []
    var zs = []
    for (let i = 0; i < 1; i += 0.001) {
        zs.push(i)
    }
    for (let i = 1; i < 2.5; i += 0.1) {
        zs.push(i)
    }
    
    function drawSN() {
        sseHypothesis = 0
        
        ctxB.lineWidth = 1
        ctxB.fillStyle = black ? "black" : "white"
        ctxB.fillRect(0, 0, graph.width, graph.height)

        ctxB.strokeStyle = !black ? "black" : "white"
        ctxB.strokeRect(offset, -10, graph.width, graph.height + 10 - offset)

        ctxB.fillStyle = !black ? "black" : "white"

        var t
        if (drawHypothesis.value > 0) {
            ctxB.strokeStyle = black ? "red" : "black"
            ctxB.beginPath()
            ctxB.moveTo(offset, graph.height - offset)

            let H0 = drawHypothesis.value
            zs.forEach(z => {
                //d = ii/(1+ii) * c0 / drawHypothesis.value * pc2ly
                t = c0 / H0 * Math.log(1 + z)
                
                if (yAxis.selectedIndex === 2) {
                    t = t * (1 + z) //* 1000000
                    t = (5 * Math.log10(t) + 25 - 28) * 1000
                }
                else {
                    t = t * pc2ly
                }
                ctxB.lineTo( offset + z * zZoom * zoomG, 
                            -offset + graph.height - t * zoomGY)
            })

            ctxB.stroke()
        }

        var dz
        



        setLCDM()
        ctxB.lineWidth = 1
        ctxB.strokeStyle = "green"
        ctxB.beginPath()
        ctxB.moveTo(offset, graph.height - offset)

        zs.forEach(z => {
            d = zToD(z)  
            if (yAxis.selectedIndex === 2) {
                d = d * (1 + z) //* 1000000
                d = (5 * Math.log10(d) + 25 - 28) * 1000
            }
            else {
                d = d * pc2ly
            }
            ctxB.lineTo( offset + z * zZoom * zoomG, 
                        -offset + graph.height - d * zoomGY)
        })
        ctxB.stroke()

    
        ctxB.fillStyle = black ? "yellow" : "red"
        var x, y
        for (var sn of snData) {
            //sn.d = sn.ld
            if (yAxis.selectedIndex === 1) {
                y = sn.ld
            }
            else if (yAxis.selectedIndex === 2) {
                y = (sn.dm - 28) * 1000
            }
            else {
                y = sn.d // (1 + sn.z)
            }

            x = sn.z * zZoom

            ctxB.fillRect(offset + x * zoomG - 1, graph.height - offset - y * zoomGY - 1, 2, 2)

            if (sn.z && sn.d) {
                calculateError(sn.z, sn.d)
            }
            
        }

        sseHypothesisDiv.innerHTML = Math.round(sseHypothesis)
        sseLCDMDiv.innerHTML = Math.round(sseLCDM)


        ctxB.font = "14px sans-serif"

        ctxB.fillRect(offset + 16, offset + 33, 2, 2)
        ctxB.fillStyle = "black"
        ctxB.fillText("Pantheon+SH0ES", offset + 5 + 20, offset + 38)
        //ctxB.fillText("comoving distance", offset + 5 + 20, offset + 54)


        ctxB.fillStyle = !black ? "black" : "white"
        ctxB.textAlign = "right"
        ctxB.fillText(xAxis.value, graph.width - 4, graph.height - 30)
        ctxB.textAlign = "left"
        ctxB.fillText(yAxis.value, offset + 5, offset)
        
        
        var dgi
        ctxB.font = "10px sans-serif"
        if (xAxis.selectedIndex === 0) {
            
            if (yAxis.selectedIndex === 2) {
                for (dgi = 28; dgi < 50; dgi+=5) {
                    ctxB.fillText(dgi, 4, -offset + graph.height - (dgi - 28) * 1000 * zoomGY + 4)    
                }
            }
            else {
                for (dgi = 0; dgi < 80; dgi+=5) {
                    ctxB.fillText(dgi, 4, -offset + graph.height - dgi * 1000 * zoomGY + 4)    
                }
            }            
            
            for (dgi = 0; dgi < 110; dgi+=5) {
                ctxB.fillText(dgi / 10, offset + dgi / 10 * zZoom * zoomG + 4, graph.height - 5)    
            }
        }
        
        
    }
    fetch("https://mikehelland.github.io/hubbles-law/data/Pantheon+SH0ES_z_mu.csv").then(res => res.text()).then(text => {
        //console.log(text)

        var lines = text.split("\n")
        for (var i = 1; i < lines.length; i++) {
            var line = lines[i].split(",")
            snData.push({"dm": parseFloat(line[2]), "z": parseFloat(line[0])})
        }
        calculateDistances()
        
        //drawSN()
        calculateLCDMError()

        //fetch("https://mikehelland.github.io/hubbles-law/data/zdata_ned.json").then(res=>res.json()).then(data=> {
        //    zData = data
        //})
    })

    

document.getElementById("graph-zoom-x").onchange = e => {
    zoomG = zoom * zoom_gx * e.target.value
    drawSN()
}
document.getElementById("graph-zoom-y").onchange = e => {
    zoomGY = zoom * zoom_gy * e.target.value
    drawSN()
}

var yAxis = document.getElementById("graph-y-axis")
var xAxis = document.getElementById("graph-x-axis")
yAxis.onchange = e => drawSN()
xAxis.onchange = e => drawSN()
drawHypothesis.onchange = e => drawSN()

    function calculateError(z, d) {

        var dhypothesis = c0 / drawHypothesis.value * pc2ly * Math.log(1+parseFloat(z))
        var se = Math.pow(d - dhypothesis, 2)
        sseHypothesis += se

                
        
    }

    function calculateLCDMError() {
        sseLCDM = 0
        var dlcdm
        var se
        setLCDM()
        snData.forEach(sn => {
            if (sn.z && sn.d) {
                dlcdm = zToD(sn.z * 1) * pc2ly
                se = Math.pow(sn.d - dlcdm, 2)
                //console.log(sn.z, sn.d, dlcdm, se)
                sseLCDM += se
            }
        })
        drawSN()
    }


function fun(v1, Omega_M, Omega_L, Omega_k) {
        v2 = v1 * v1
        v3 = v1 * v1 * v1
        f = Math.sqrt(Omega_M * v3 + Omega_k * v2 + Omega_L)
        return 1. / f
    };

    function simpson(x0, x2) {
        h = (x2 - x0) / 2.
        x1 = x0 + h
        igr = h * (fun(x0, Omega_M, Omega_L, Omega_k) + 4. * fun(x1, Omega_M, Omega_L, Omega_k) + fun(x2, Omega_M, Omega_L, Omega_k)) / 3.
        return igr
    };

    function sumint(z1) {
        integrale = 0, zone = 1, deltaz = 0.001
        while (zone <= (z1 - deltaz)) {
            zini = zone
            zfin = zone + deltaz
            integrale += simpson(zini, zfin);
            zone += deltaz
        }
        return integrale
    };

    // -------------------------------------------- 


    function lookfun(v1, Omega_M, Omega_L, Omega_k) {
        v2 = v1 * v1
        v3 = v1 * v1 * v1
        f = v1 * Math.sqrt(Omega_M * v3 + Omega_k * v2 + Omega_L)
        return 1. / f
    };

    function timeint(z1start, z1end) {
        s = 0, a = z1start, b = z1end
        s = 0.5 * (b - a) * (lookfun(a, Omega_M, Omega_L, Omega_k) + lookfun(b, Omega_M, Omega_L, Omega_k))
        n = 2
        while (n <= 11) {
            n2 = n - 2
            it = Math.pow(2, n2)
            tnm = it
            del = (b - a) / tnm
            x = a + 0.5 * del
            sum = 0.
            j = 1
            while (j <= it) {
                sum = sum + lookfun(x, Omega_M, Omega_L, Omega_k)
                x = x + del
                j += 1
            }
            s = 0.5 * (s + (b - a) * sum / tnm)
            n += 1
        }
        return s
    };

    // --------------------------------------------

    function sinh(x) {
        s = (Math.exp(x) - Math.exp(-x)) / 2.
        return s
    };

    var OmegaMinput = document.getElementById("Omega_M")
    var OmegaLinput = document.getElementById("Omega_L")    
    var H0input = document.getElementById("H0")    
    var Omega_L, Omega_M, H0, Omega_k
    OmegaMinput.onchange = e => calculateLCDMError()
    OmegaLinput.onchange = e => calculateLCDMError()
    H0input.onchange = e => calculateLCDMError()

    function setLCDM() {
        Omega_L = OmegaLinput.value * 1
        Omega_M = OmegaMinput.value * 1
        H0 = H0input.value * 1
        
    }

    function zToD(z) {
        // From redshift to distance
        

        z1 = 1. + z;
        h = H0 / 100.;
        Tnorm = 9.77810945 / h;
        cvel = 299792.458
        ch0 = cvel / H0;
        pig = 3.1415926536;
        rad = pig / 180.;
        q0 = Omega_M / 2. - Omega_L;
        Omega_k = 1. - Omega_M - Omega_L;

        age = (timeint(1., 50.)) * Tnorm;

        if (Omega_L > 0. && Omega_k == 0.) {
            DC = ch0 * sumint(z1);
            DL = DC * z1
        }
        if (Omega_L > 0. && Omega_k < 0.) {
            curv = Math.sqrt(-Omega_k)
            r = sumint(z1);
            DC = ch0 * Math.sin(r * curv) / curv
            DL = DC * z1
        }
        if (Omega_L > 0. && Omega_k > 0.) {
            curv = Math.sqrt(Omega_k)
            r = sumint(z1);
            DC = ch0 * sinh(r * curv) / curv
            DL = DC * z1
        }
        if (Omega_L == 0. && q0 > 0) {
            q0sq = q0 * q0
            a = 1. - q0 + q0 * z + (q0 - 1.) * (Math.sqrt(2. * q0 * z + 1.))
            DL = ch0 * a / q0sq
            DC = DL / z1
        }
        if (Omega_L == 0. && q0 == 0) {
            DL = ch0 * z * (1. + z / 2.)
            DC = DL / z1
        }
        // Lookback time
        lookback = timeint(1., z1) * Tnorm
        // Angular distance
        DA = DL / (z1 * z1)
        // Lunghezza in primi corrispondente a 1 Mpc.
        angle = (60. / rad) * z1 * z1 / DL;
        // Length in Mpc corresponding to 1 degree on the sky
        R = rad * DL / (z1 * z1);

        // Display result in the form.
        /*
        form.q0.value = q0.toFixed(2);
        form.Omega_k.value = Omega_k.toFixed(2);
        form.dlum.value = DL.toFixed(1);
        form.dcom.value = DC.toFixed(1);
        form.dang.value = DA.toFixed(1);
        form.lsep.value = R.toFixed(1);
        form.asep.value = angle.toFixed(1);
        form.look.value = lookback.toFixed(1);
        form.age.value = age.toFixed(1);
        */
       return DC
    }

    function hyperbolicTime(t) {
        /*
            \theta = \cosh^{-1}(\frac{R^4} + \sqrt{R^2 + 2R^2 t^2}{2R^2})
        */
        return Math.acosh((
            Math.pow(H, 2) + Math.sqrt(Math.pow(H, 4) + 2 * Math.pow(H, 2) * Math.pow(t, 2) )) / 
            (2 * Math.pow(H, 2)))

    }
    

    
</script>

<script type="text/javascript" src="https://www.hostmath.com/Math/MathJax.js?config=OK"></script>
