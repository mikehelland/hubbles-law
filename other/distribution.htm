<!DOCTYPE html>
<html>
    <head>
        <style>
            
        </style>
    </head>
    <body>
        <p>The <a href="../index.htm">alternative model</a> predicts that the number of galaxies in each volume should be equal.</p>
        <hr>
        

        Divide the volume by <span id="divideByCap"></span>
        <input type="range" min="1" max="500" id="divideBy">



        <br>
        Distance between dots <span id="distanceBetweenCap"></span>
        <input type="range" min="1" max="500" id="distanceBetween">


        <hr>
        <div style="position: relative;">
            <select id="catalog" style="position: absolute; top:10px; left: 60px;">
                <option value="select">Select a quasar/AGN catalog...</option>
                <option value="1996">Quasars and Active Galactic Nuclei (7th Ed., 1996)</option>
                <option value="2010">Quasars and Active Galactic Nuclei (13th Ed., 2010)</option>
                <option value="milli">The Million Quasars (Milliquas) catalogue, version 8 (Flesch, 2023)</option>
                <option value="sdss">SDSS DR16Q_v4</option>
                <option value="siena">Siena Galaxy Atlas</option>
            </select>

            <canvas id="graph" width="1200" height="400"></canvas>

        </div>

        <hr>
        <canvas id="canvas" width="800" height="800"></canvas>


        <pre style="padding-left: 80px; font-size: 20pt; overflow: scroll;" id="outputDiv"></pre>

        <hr>

        <ul>
            <li>
                <a href="https://cdsarc.cds.unistra.fr/ftp/VII/188/">Quasars and Active Galactic Nuclei</a> 7th Ed.  (Veron+ 1996)
            </li>
            <li>
                <a href="https://cdsarc.cds.unistra.fr/ftp/VII/258/">Quasars and Active Galactic Nuclei</a> 13th Ed.  (Veron+ 2010)
            </li>
            <li>
                <a href="https://cdsarc.cds.unistra.fr/ftp/VII/294/">The Million Quasars (Milliquas) catalogue</a> version 8 (Flesch, 2023)
            </li>
            
        </ul>

        
        <script>
            var agn = []
            var qso = []

            var maxZ = 1
            var maxY

            catalog.onchange = () => {
                if (catalog.value !== "select") {
                    drawV()

                    if (!ctlgs[catalog.value]) {
                        download(catalog.value)
                    }
                    else {
                        binData(catalog.value)
                    }
                }
            }


            var ctlgs = {}

            var dots = []
            makeDots()


            divideBy.onchange = () => {
                N = 1 * divideBy.value
                divideByCap.innerHTML = N
                drawV()

                binData()
            }

            distanceBetweenCap.innerHTML = distanceBetween.value
                
            distanceBetween.onchange = () => {
                //N = 1 * distanceBetween.value
                distanceBetweenCap.innerHTML = distanceBetween.value
                makeDots()
                drawV()

                binData()
            }


            const pi = Math.PI
            const kpi = 4 / 3 * pi

            var R = 350

            var zoom = 1

            // was volume, but is really area
            var V = pi * R**2
            

            var N = 3
            divideBy.value = N
            divideByCap.innerHTML = N

            var Vs = []

            var ctxc = canvas.getContext("2d")

            var drawV = function () {
                canvas.width = canvas.width
                ctxc.font = "bold 20pt Arial"

                //ctx.fillText(Math.round(V), 20, 20) 

                ctxc.translate(canvas.width / 2, canvas.height / 2)

                ctxc.beginPath()
                ctxc.arc(0, 0, zoom * R, 0, pi * 2)
                ctxc.stroke()

                ctxc.beginPath()
                ctxc.arc(0, 0, 1, 0, pi * 2)
                ctxc.stroke()

                var lastr = 0
                var lastz = 0

                ctxc.textAlign = "right"

                Vs = []
                var output = ""

                for (var i = 0; i < N; i++) {
                    var Vn = V/N * (1 + i)
                    var r = (Vn / pi)**(1/2)
                    var z = 1 / (1-r/R) - 1

                    var cap = z.toFixed(2)
                    if (z > 1e12) {
                        z = Infinity
                        cap = "âˆž"
                    }
                                    
                    Vs.push({Vn: V/N, r, z, agn: 0, qso: 0})

                    ctxc.beginPath()
                    ctxc.arc(0, 0, zoom * r, 0, pi * 2)
                    ctxc.stroke()

                    ctxc.fillText(cap, 0, 4 + -zoom * (lastr + (r - lastr) / 2)) 

                    output += lastz.toFixed(2) + " < z < " + cap  + "\n" 

                    lastr = r
                    lastz = z

                }

                ctxc.fillStyle = "red"
                for (i = 0; i < dots.length; i++) {
                    ctxc.beginPath()
                    ctxc.arc(dots[i][0], dots[i][1], 5, 0, Math.PI * 2)
                    ctxc.fill()
                }

                console.log(Vs)

                outputDiv.innerHTML = output
            }

            var binData = function () {

                for (var i = 0; i < dots.length; i++) {
                    for (var iz = 0; iz < Vs.length; iz++) {
                        if (Math.sqrt(dots[i][0]**2 + dots[i][1]**2) < Vs[iz].r) {
                            
                            Vs[iz].agn++
                            break
                        }
                    }
                }

                drawG()

            }

            drawV()
            binData()
            drawG()


            function drawG() {
                var ctx = graph.getContext("2d")

                graph.width = graph.width
                ctx.translate(40, graph.height - 20)

                var i0 = 0 //exclude0.checked ? 1 : 0

                var maxBin = 0
                for (var i = 0; i < Vs.length; i++) {
                    if (Vs[i].z > maxZ) {
                        maxBin = i + 1
                        break
                    }
                }
                maxBin = Vs.length
                console.log(maxBin)

                var maxY = 0
                for (var i = i0; i < Vs.length; i++) {
                    if (Vs[i].agn + Vs[i].qso > maxY) {
                        maxY = Vs[i].agn + Vs[i].qso
                    }
                }
                
                var xz = (graph.width - 20) / (maxBin + 1)
                var yz = (graph.height - 50) / maxY
                console.log(yz)
                if (isNaN(yz) || yz === Infinity) yz = 0

                ctx.strokeRect(0, 0, graph.width, -graph.height)

                ctx.textAlign = "right"
                ctx.fillText("Redshift z", graph.width - 60, -2)

                for (var i = 0; i < maxY; i += 2000) {
                    ctx.fillText(Math.round(i/1000) +"K", -4, 4 + i * -yz)
                }

                ctx.textAlign = "center"
                
                for (i = 0; i < maxBin; i++) {
                    ctx.fillStyle = "black"
                    if (xz > 40 || i%2 === 0) {
                        ctx.fillText(Vs[i].z.toFixed(2), (i + 1) * xz, 14)
                    }

                    var h = 
                    ctx.fillStyle = "red"
                    ctx.fillRect(i * xz + 2, 0, xz - 4, (Vs[i].qso + Vs[i].agn) * -yz)

                    ctx.fillStyle = "blue"
                    ctx.fillRect(i * xz + 2, 0, xz - 4, -Vs[i].qso * yz)
                }

                
            }

            function makeDots() {
                var distance = parseFloat(distanceBetween.value)

                dots = []
                for (var j = 0; j < 40; j++) {
                    for (var i = 0; i < 40; i++) {
                        dots.push([i * distance, j * distance])
                        if (i > 0) {
                            dots.push([-i * distance, j * distance])
                        }

                        if (j > 0) {
                            dots.push([i * distance, -j * distance])
                            dots.push([-i * distance, -j * distance])
                        }
                    }
                }
            }
        </script>


    </body>
</html>