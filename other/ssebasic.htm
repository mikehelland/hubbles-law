<!DOCTYPE html>
<html>

<body>

    <h2 id="output"></h2>

<script>

var Hstart = 66
const Hend = 78.5


var sse = []
var sseHypothesis = 0
var sseLCDM = 0
var lowestHypothesis = 0
var lowestLCDM = 0
 

var snData = []
var url = "https://mikehelland.github.io/hubbles-law/data/Pantheon+SH0ES_z_mu.csv"
fetch(url).then(res => res.text()).then(text => {

    var lines = text.split("\n")
    for (var i = 1; i < lines.length; i++) {
        var line = lines[i].split(",")
        if (line[0]) {
            snData.push({
                "z": parseFloat(line[0]), 
                "mu": parseFloat(line[2]), 
                "muerr": parseFloat(line[3])})
        }
        
    }

    output.innerHTML = calculateSSE(70.5)

})




function calculateRange() {        
    for (var H = Hstart; H < Hend; H += 0.1) {

        var sse = calculateSSE(H)

        if (!lowestHypothesis || sse < lowestHypothesis.sse) {
            lowestHypothesis = {sse: sse, H0: H}
        }
        sse.push({H: H, 
            hypothesis: sseHypothesis, 
            lcdm: sseLCDM    
        })
    }
    
}
    


const c = 299792.458

function calculateSSE(H0) {

    // sum the squared errors for each supernova 
    var sse = 0
    snData.forEach(sn => {

        // calculate luminosity distance according to the hypothesis
        // from the redshift in the data
        var dL = c / H0 * (1 + sn.z) * Math.log(1 + sn.z)

        // calculate distance modulus
        var mu = 5 * Math.log10(dL) + 25 
        
        //compare that to the distance modulus in the data
        var err = Math.pow(sn.mu - mu, 2) / Math.pow(sn.muerr, 2)

        sse += err
    })

    return sse
}



    function calculateLCDMError(sn) {
        sseLCDM = 0
        var dlcdm = zToD(sn.z) 
        var dd 
        
        if (useMu) {
            dlcdm = dlcdm * (1 + sn.z)  
            dlcdm = calculateDistanceModulus(dlcdm)
            dd = sn.dm
        }
        else {
            dd = sn.d 
        }    
        
        return Math.pow(dd - dlcdm, 2) / (useError ? Math.pow(sn.derr, 2) : 1) 
        
    }

    var handle
    function calculateLCDMErrors() {
        clearInterval(handle)
        console.log("calcaulting lcdms")
        var sseLCDM
        var i = 0
        lowestLCDM = 0 
        handle = setInterval(() => {

            sseLCDM = 0

            setLCDM(sse[i].H)
            snData.forEach(sn => {
                sseLCDM += calculateLCDMError(sn)
            })
            sse[i].lcdm = sseLCDM
            i++

            if (!lowestLCDM || sseLCDM < lowestLCDM.sse) {
                lowestLCDM = {sse: sseLCDM, H0: sse[i].H}
            }

            if (i >= sse.length) {
                clearInterval(handle)
            }

            drawData()

        }, 0)

    }


function fun(v1, Omega_M, Omega_L, Omega_k) {
        v2 = v1 * v1
        v3 = v1 * v1 * v1
        f = Math.sqrt(Omega_M * v3 + Omega_k * v2 + Omega_L)
        return 1. / f
    };

    function simpson(x0, x2) {
        h = (x2 - x0) / 2.
        x1 = x0 + h
        igr = h * (fun(x0, Omega_M, Omega_L, Omega_k) + 4. * fun(x1, Omega_M, Omega_L, Omega_k) + fun(x2, Omega_M, Omega_L, Omega_k)) / 3.
        return igr
    };

    function sumint(z1) {
        integrale = 0, zone = 1, deltaz = 0.001
        while (zone <= (z1 - deltaz)) {
            zini = zone
            zfin = zone + deltaz
            integrale += simpson(zini, zfin);
            zone += deltaz
        }
        return integrale
    };

    // -------------------------------------------- 


    function lookfun(v1, Omega_M, Omega_L, Omega_k) {
        v2 = v1 * v1
        v3 = v1 * v1 * v1
        f = v1 * Math.sqrt(Omega_M * v3 + Omega_k * v2 + Omega_L)
        return 1. / f
    };

    function timeint(z1start, z1end) {
        s = 0, a = z1start, b = z1end
        s = 0.5 * (b - a) * (lookfun(a, Omega_M, Omega_L, Omega_k) + lookfun(b, Omega_M, Omega_L, Omega_k))
        n = 2
        while (n <= 11) {
            n2 = n - 2
            it = Math.pow(2, n2)
            tnm = it
            del = (b - a) / tnm
            x = a + 0.5 * del
            sum = 0.
            j = 1
            while (j <= it) {
                sum = sum + lookfun(x, Omega_M, Omega_L, Omega_k)
                x = x + del
                j += 1
            }
            s = 0.5 * (s + (b - a) * sum / tnm)
            n += 1
        }
        return s
    };

    // --------------------------------------------

    function sinh(x) {
        s = (Math.exp(x) - Math.exp(-x)) / 2.
        return s
    };

    var OmegaMinput = document.getElementById("Omega_M")
    var OmegaLinput = document.getElementById("Omega_L")    
    var Omega_L, Omega_M, H0, Omega_k
    OmegaMinput.onchange = e => calculateLCDMError()
    OmegaLinput.onchange = e => calculateLCDMError()
    
    function setLCDM(H) {
        Omega_L = OmegaLinput.value * 1
        Omega_M = OmegaMinput.value * 1
        H0 = H
        
    }

    function zToD(z) {
        // From redshift to distance
        

        z1 = 1. + z;
        h = H0 / 100.;
        Tnorm = 9.77810945 / h;
        cvel = 299792.458
        ch0 = cvel / H0;
        pig = 3.1415926536;
        rad = pig / 180.;
        q0 = Omega_M / 2. - Omega_L;
        Omega_k = 1. - Omega_M - Omega_L;

        age = (timeint(1., 50.)) * Tnorm;

        if (Omega_L > 0. && Omega_k == 0.) {
            DC = ch0 * sumint(z1);
            DL = DC * z1
        }
        if (Omega_L > 0. && Omega_k < 0.) {
            curv = Math.sqrt(-Omega_k)
            r = sumint(z1);
            DC = ch0 * Math.sin(r * curv) / curv
            DL = DC * z1
        }
        if (Omega_L > 0. && Omega_k > 0.) {
            curv = Math.sqrt(Omega_k)
            r = sumint(z1);
            DC = ch0 * sinh(r * curv) / curv
            DL = DC * z1
        }
        if (Omega_L == 0. && q0 > 0) {
            q0sq = q0 * q0
            a = 1. - q0 + q0 * z + (q0 - 1.) * (Math.sqrt(2. * q0 * z + 1.))
            DL = ch0 * a / q0sq
            DC = DL / z1
        }
        if (Omega_L == 0. && q0 == 0) {
            DL = ch0 * z * (1. + z / 2.)
            DC = DL / z1
        }
        // Lookback time
        lookback = timeint(1., z1) * Tnorm
        // Angular distance
        DA = DL / (z1 * z1)
        // Lunghezza in primi corrispondente a 1 Mpc.
        angle = (60. / rad) * z1 * z1 / DL;
        // Length in Mpc corresponding to 1 degree on the sky
        R = rad * DL / (z1 * z1);

        // Display result in the form.
        /*
        form.q0.value = q0.toFixed(2);
        form.Omega_k.value = Omega_k.toFixed(2);
        form.dlum.value = DL.toFixed(1);
        form.dcom.value = DC.toFixed(1);
        form.dang.value = DA.toFixed(1);
        form.lsep.value = R.toFixed(1);
        form.asep.value = angle.toFixed(1);
        form.look.value = lookback.toFixed(1);
        form.age.value = age.toFixed(1);
        */
       return DC
    }


    
</script>

<script type="text/javascript" src="https://www.hostmath.com/Math/MathJax.js?config=OK"></script>
