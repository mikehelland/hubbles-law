<!DOCTYPE html>
<html>
    <head><style>
        body {background-color: #808080;}
    </style></head>

<body>

    <span id="dxCaption">50</span>
    <input id="dxInput" type="range"  min="1" max="250" value="50">
    
    <input id="rInput" type="range"  min="0" value="0">
    
    <br>
    <canvas height="900" width="900" id="canvas"></canvas>

<script>

    const pi = Math.PI
    const sin = Math.sin
    const cos = Math.cos
    var canvas = document.getElementById("canvas")
    var ctx = canvas.getContext("2d")

    var w = canvas.width
    var h = canvas.height

    var R = w/5
    var r = 8


    // incremental change in radius to test
    var dr = 10
    var dx = 50

    var testCircle
    var boxes0 = fillSphere(0, 0, 0, R) 

    rInput.onchange = () => {
        boxes0 = fillSphere(parseFloat(rInput.value), 0, 0, R) 
    
        update()
    }

    dxInput.onchange = () => {
        dx = parseFloat(dxInput.value)
        dxCaption.innerHTML = dx
    
        boxes0 = fillSphere(parseFloat(rInput.value), 0, 0, R) 

        update()
    
    }

    update()

    function update() {
        canvas.width = canvas.width
        ctx.fillStyle = "black"
        ctx.fillRect(0, 0, w, h)

        ctx.translate(w / 2, h / 2)

        var inBoxes = 0
        var outBoxes = 0
        var inGradient = 0
        var outGradient = 0

        drawCircle(0, -R)
        drawCircle(-R, R)
        drawCircle(R, R)

        drawBoxes(boxes0)

        return
        
        //for (var ib = boxes0.data.length - 1; ib >= 0; ib--) {
        for (var ib = 0; ib < boxes0.data.length; ib++) {
            for (var jb = 0; jb < boxes0.data[ib].length; jb++) {
                testCircle = fillCircle(boxes0.data[ib][jb].x, boxes0.data[0][jb].y, 0, R)
                
                inBoxes += testCircle.inBoxes 
                outBoxes += testCircle.outBoxes 
                inGradient += testCircle.inGradient 
                outGradient += testCircle.outGradient 
                
                // don't draw if we're tiny
                if (dx >= 1) {
                    drawBoxes(testCircle)
                }
            }
        }

        ctx.font = "20pt Courier"
        ctx.fillText("inBoxes: " + inBoxes, 
            -300, -canvas.height / 2 + 20)
        ctx.fillText("outBoxes: " + outBoxes, 
            -300, -canvas.height / 2 + 50)
        ctx.fillText("%: " + (outBoxes / (outBoxes + inBoxes)), 
            -300, -canvas.height / 2 + 80)

        ctx.fillText("inGradient: " + inGradient.toFixed(3), 
            0, -canvas.height / 2 + 20)
        ctx.fillText("outGradient: " + outGradient.toFixed(3), 
            0, -canvas.height / 2 + 50)

    }

    function drawCircle(x, y) {

        ctx.fillStyle = "blue"
        ctx.beginPath()
        ctx.arc(x, y, r, 0, Math.PI * 2)
        ctx.fill()

        ctx.lineWidth = 3
        ctx.strokeStyle = "blue"
        ctx.beginPath()
        ctx.arc(x, y, R, 0, Math.PI * 2)
        ctx.stroke()

    }

    var dbi, dbj
    function drawBoxes(sphere) {
        ctx.fillStyle = "white"
        
        //ctx.translate(circle.x, circle.y)
        
        /*
        for (dbi = 0; dbi < circle.data.length; dbi++) {
            for (dbj = 0; dbj < circle.data[dbi].length; dbj++) {
                
                ctx.fillStyle = circle.data[dbi][dbj].in ? "white" : "red"
                ctx.globalAlpha = circle.data[dbi][dbj].alpha
                ctx.fillRect(
                    circle.data[dbi][dbj].x - dx/2, 
                    circle.data[dbi][dbj].z - dx/2,
                    dx, dx)
            }
        } 
        */
        for (dbi = 0; dbi < sphere.data.length; dbi++) {
            //continue            
            ctx.fillStyle = sphere.data[dbi].in ? "white" : "red"
            ctx.globalAlpha = sphere.data[dbi].alpha
            ctx.fillRect(
                sphere.data[dbi].x - dx/2, 
                -R + sphere.data[dbi].y - dx/2,
                dx, dx)

            ctx.fillRect(
                R + sphere.data[dbi].x - dx/2, 
                R + sphere.data[dbi].z - dx/2,
                dx, dx)

            ctx.fillRect(
                -R + sphere.data[dbi].y - dx/2, 
                R + sphere.data[dbi].z - dx/2,
                dx, dx)

        }
                
        //ctx.translate(-circle.x, -circle.y)
    }

    function fillSphere(x, y, z) {
        var boxes = []
        var output = {x, y, z, data: boxes, circles: []}
        var origin = {x, y, z}

        var line = 2 * pi * R
        var boxCount = Math.floor(R - dx/2) / dx //line / dx
        
        fillCircle(x, y, 0, R, origin, boxes)

        var ir = dx

        while (ir <  R) {

            var angle = Math.asin(ir / R)
            line = R * cos(angle)

            fillCircle(x, y, ir, line, origin, boxes)
            fillCircle(x, y, -ir, line, origin, boxes)
            
            ir += dx
        }


        return output
    }

    /*
    output.inBoxes = 0
    output.outBoxes = 0
    output.inGradient = 0
    output.outGradient = 0
    if (box.in) {
        output.inBoxes++
        output.inGradient += box.alpha
    }
    else {
        output.outBoxes++
        output.outGradient += box.alpha
    }
    */


    function fillCircle(x, y, z, r, origin, boxes) {
        var ir = r

        var x0 = -x
        var y0 = -y

        var ia

        while (ir >= 0) {

            //var boxes = []

            // find the circumfrence
            var line = 2 * pi * ir

            // find how many boxes fit in the cirucumference
            boxCount = line / dx
            boxAngle = 2 * pi / boxCount

            // place boxes along the circumference
            var angle = 0
            
            for (ia = 0; ia < boxCount; ia++) {
                var box = {
                    r: ir, 
                    angle: ia * boxAngle, 
                    alpha: 1 - ir / R, 
                    x: x + ir * cos(ia * boxAngle),
                    y: y + ir * sin(ia * boxAngle),
                    z
                }
                boxes.push(box)

                var rr = ((box.x - origin.x)**2 +
                        (box.y - origin.y)**2 +
                        (box.z - origin.z)**2)**0.5
                box.alpha = 1 - rr/R
                box.in = ((box.x)**2 + (box.y)**2 + (box.z)**2)**0.5 < R
            }
             
            ir -= dx

            //output.data.push(boxes)
        }

        //return output

    }

    function testCircle(x, y) {


    }


</script>

</body>


</html>