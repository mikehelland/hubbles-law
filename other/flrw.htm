<!DOCTYPE html>
<html>
<head>
<style>
    input[type=number] {font-size: 125%; width: 200px;}
    body {font-size: 150%;}
</style>
</head>
<body>

    <form name="form">
    <p>
    &Lambda;CDM : 
    <br>
    H<sub>0</sub>: <input type="number" value="70" step="0.5" id="H0">
    &Omega;<sub>M</sub>: <input type="number" min="0" value="0.3" step="0.05" id="Omega_M">
    &Omega;<sub>&Lambda;</sub>: <input type="number" min="0" value="0.7" step="0.05" id="Omega_L">
    </p>    
    </form>

    
    <canvas id="canvas" width="1000" height="600"></canvas>



    <script src="flrw.js"></script>
    <p>(<span style="color:red;">red</span>) JavaScript Cosmology Calculator by <a href="http://www.bo.astro.it/~cappi/cosmotools" target="_blank">Alberto Cappi</a>
    </p>

    <p>(black):</p>
    <pre>
var findZ = 10
var H0 = 70
var OmegaL = 0.7
var OmegaM = 1 - OmegaL

// convert km/s/Mpc  to  Mly/My/Mly
H0 = H0 / 3.08e19 * 60 * 60 * 24 * 365 * 1e6
var H = H0 
var c = 1

// the photons, x1 has a head start
var x1 = 0.1
var x2 = 0

var t = 0, z = 0, data = []

while (z < findZ) {
    t--

    // move the photons 
    x1 += c - H * x1
    x2 += c - H * x2

    // compare their separation
    z = 0.1 / (x1 - x2) - 1
    
    // update the Hubble parameter
    H = H0 * Math.sqrt(OmegaM * 
        Math.pow(1 + z, 3) + OmegaL)

    data.push({
        z,
        d_A: x2,
        d_C: x2 * (1+z),
        d_T: -c * t
    })
}
    </pre>

    <script>
        var data
        var data2
        const c = 299792.458
        const pc2ly = 3.261564
        var zoomY = 35 * 1000
        
        var maxZ = 10

        form.H0.onchange = e => run()
        form.Omega_L.onchange = e => {
            form.Omega_M.value = 1 - form.Omega_L.value
            run()
        }
        form.Omega_M.onchange = e => {
            form.Omega_L.value = 1 - form.Omega_M.value
            run()
        }
        
        run()

        function run() {
            var H0 = parseFloat(form.H0.value)
            var OmegaL = parseFloat(form.Omega_L.value)
            var OmegaM = parseFloat(form.Omega_M.value)

            data = []
            for (var i = 0; i <= maxZ; i=i+0.1) {
                data.push(FLRW(H0, OmegaL, OmegaM, i))
            }
            
            //data2 = flrw(H0, OmegaL, OmegaM, maxZ)
            data2 = flrw2(H0, OmegaL, maxZ)
            
            drawCanvas()

        }

        function drawCanvas() {

            var ctx = canvas.getContext("2d")
            var h = canvas.height
            var w = canvas.width
            canvas.width = w

            ctx.fillStyle = "black"
            ctx.font = "16px sans-serif"
            for (var i = 0; i <= maxZ; i=i+1) {
                ctx.fillText(i, 20 + i / maxZ * w, h)
            }
            ctx.fillText("z", w - 10, h)

            ctx.textAlign = "right"
            for (var i = 0; i <= zoomY; i=i+2000) {
                ctx.fillText(i / 1000, 18, h - 20 - h * i / zoomY)
            }
            ctx.textAlign = "left"
            ctx.fillText("billion light years", 28, 18)

            
            ctx.translate(20, -20)

            ctx.lineWidth = 1
            ctx.strokeRect(0, 0, canvas.width, canvas.height)
            
            /*ctx.fillStyle = "black"
            data2.forEach(dp => {
                ctx.fillRect(w * dp.z / maxZ, h / 2, 1, 1)
            })*/

            ctx.lineWidth = 10
            ctx.strokeStyle = "red"
            ctx.beginPath()
            ctx.moveTo(0, h)

            data.forEach(dp => {
                ctx.lineTo(w * dp.z / maxZ, h - h * dp.lookback * 1000 / zoomY)
            })
            ctx.globalAlpha = 0.4
            ctx.stroke()


            ctx.beginPath()
            ctx.moveTo(0, h)

            data.forEach(dp => {
                ctx.lineTo(w * dp.z / maxZ, h - h * dp.DA * pc2ly / zoomY)
            })
            ctx.globalAlpha = 0.4
            ctx.stroke()

            ctx.beginPath()
            ctx.moveTo(0, h)

            data.forEach(dp => {
                ctx.lineTo(w * dp.z / maxZ, h - h * dp.DC * pc2ly / zoomY)
            })
            ctx.globalAlpha = 0.4
            ctx.stroke()

            ctx.globalAlpha = 1
            ctx.lineWidth = 4
            ctx.strokeStyle = "black"

            ctx.setLineDash([50, 10])
            ctx.beginPath()
            ctx.moveTo(0, h)

            data2.forEach(dp => {
                ctx.lineTo(w * dp.z / maxZ, h - h * dp.d_T / zoomY)
            })
            ctx.stroke()


            ctx.setLineDash([])
            ctx.beginPath()
            ctx.moveTo(0, h)

            var dp
            for (i = 0; i < data2.length; i++) {
                dp = data2[i]
                if (dp.z) {
                    ctx.lineTo(w * dp.z / maxZ, h - h * dp.d_A / zoomY)
                }
            }
            ctx.stroke()

            ctx.setLineDash([5, 5])
            ctx.beginPath()
            ctx.moveTo(0, h)

            data2.forEach(dp => {
                ctx.lineTo(w * dp.z / maxZ, h - h * dp.d_C / zoomY)
            })
            ctx.stroke()

        }











    </script>